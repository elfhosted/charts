apiVersion: v1
kind: ConfigMap
metadata:
  name: filebrowser-elfbot-script
data:
  elfbot: |
    #!/bin/bash

    if [[ $# -lt 2 ]]; then 
        echo "usage: elfbot <command> <app> <optional>"
        echo
        echo '<app> must match an app found in /config'
        echo
        echo "valid commands are:"
        echo
        echo "elfbot restart <app> [--force] [--yesiamsure] : restarts an app"
        echo "elfbot pause <app>                            : stop an app, wait 5 min, and restart it"
        echo "elfbot reset <app> [--yesiamsure]             : resets an app to defaults"
        echo "elfbot backup <app>                           : creates a dated backup folder in under /config/<app>"
        echo "elfbot claim plex <token>                     : claims a plex server"
        echo "elfbot recyclarr <command>                    : run recyclarr (using config files in /storage/elfstorage/recyclarr)" 
        echo "elfbot env <app> <key>=<value>                : set an env var inside an app (advanced beta feature)"
        echo "elfbot blackhole <app>                        : symlink the contents of the CWD into /storage/symlinks/blackhole/<app>/ for automated import"
        echo "elfbot symlink <storage-mount>                : import remotely-mounted, read-only media as symlinks, or generate a report"
        echo "elfbot symlink report-broken                  : generate a report on all broken symlinks found under /storage/symlinks"
        echo "elfbot symlink delete-broken                  : delete (without confirmation!) all broken symlinks found under /storage/symlinks"

        echo
    fi

    case $1 in

        "restart")

            if [[ ! -d "/storage/config/$2" && $2 -ne "all" ]]; then
                echo "WARNING: /config/$2 does not exist - continuing, but this may not work"
            fi

            if [[ "$3" == "--force" && "$4" != "--yesiamsure" ]]; then
                echo force-killing a healthy pod can result in data loss! add \'--yesiamsure\' after your restart --force command to force-kill
                exit 1
            elif [[ "$3" == "--force" ]]; then
                echo "force-restarting $2, data loss may occur (but sometimes there's no other way)..."
                echo forcerestart > /elfbot/$2
            else             
                echo "restarting $2..."
                echo restart > /elfbot/$2
            fi
            ;;

        "pause")

            if [[ ! -d "/storage/config/$2" && $2 -ne "all" ]]; then
                echo "WARNING: /config/$2 does not exist - continuing, but this may not work"
            fi

            echo "pausing $2 for 5 min..."
            echo pause > /elfbot/$2
            ;;     

        "env")

            if [[ ! -d "/storage/config/$2" ]]; then
                echo "WARNING: /config/$2 does not exist - continuing, but this may not work"
            fi

            if [[ "$#" -lt 3 ]]; then  
                echo syntax is "elfbot env <app> KEY=VALUE"
                exit 1
            fi
            echo "adding $3 to env for $2, triggering a restart..."
            echo $3 > /elfbot/$2
            ;;                        

        "reset")

            if [[ ! -d "/storage/config/$2" && $2 -ne "all" ]]; then
                echo "ERROR: /config/$2 does not exist"
                exit 1
            fi

            if [[ "$3" != "--yesiamsure" ]]; then
                echo potentially dangerous! add \'--yesiamsure\' after your reset command to force
                exit 1
            fi      
            echo reset > /elfbot/$2
            echo "resetting $2..."
            ;;

        "backup")   

            if [[ ! -d "/storage/config/$2" && $2 -ne "all" ]]; then
                echo "ERROR: /config/$2 does not exist"
                exit 1
            fi

            if [[ "$2" == "all" ]]; then
                APPS=$(ls /storage/config)
                echo "Backing up multiple apps, restarting each with a 1 min delay, this may take a while..."
                SLEEP=1m
            else
                APPS=$2 # if we're just backing up one app
                SLEEP=0s
            fi  

            for APP in $APPS
            do
                if [[ "$APP" == "filebrowser" ]]; then
                    echo "skipping filebrowser (we're using it right now!)..."
                elif [[ "$APP" == "backup" ]]; then
                    echo "skipping /config/backup (no backup-ception for us!)..."                
                else
                    # FREE_SPACE=$(df -P /storage/config | grep config | awk  '{print $4}')
                    # NEEDED_SPACE=$(du -s /storage/config/$APP)

                    # if [[ "$FREE_SPACE" -lt "$NEEDED_SPACE" ]]; then
                    #     echo "Error - not enough free space for backup. We need $NEEDED_SPACE bytes, but we only have $FREE_SPACE remaining :("
                    # else
                        TIMESTAMP=$(printf '%(%Y-%m-%d--%H-%M)T\n' -1)
                        echo backup > /elfbot/$APP
                        echo "restarting $APP, backup will be saved as /storage/elfstorage/backups/$APP-$TIMESTAMP ..."
                        sleep $SLEEP
                    # fi
                fi
            done
            ;;       

        "claim")
            if [[ "$#" -lt 3 ]]; then  
                echo plex claim token missing, get one from https://www.plex.tv/claim/
                exit 1
            fi       
            if [[ ! "$3" =~ "claim-" ]]; then  
                echo plex claim token invalid, get one from https://www.plex.tv/claim/
                exit 1
            fi   
            if [[ "$2" = "plex" ]]; then

                echo "Attempting to claim Plex with claim [$3], and triggering a restart..."
                echo PLEX_CLAIM=$3 > /elfbot/plex
            else
                echo "this command is only for claiming plex"
            fi
            ;;     

        "recyclarr")
            recyclarr $2 --app-data /storage/elfstorage/recyclarr $3 $4 $5
            ;;                  

        "blackhole")

            if [[ "$#" -lt 2 ]]; then
                echo "ERROR: target missing - example : 'elfbot blackhole radarr'"
                exit 1
            fi
            ITEMPATH="$(pwd)"

            # Never symlink ourselves!
            if [[ $ITEMPATH == *"/storage/symlinks"* ]]; then
                echo "ERROR: Can't symlink a source in /storage/symlinks (#deathbysymlink)"
                exit 1
            fi

            # Get ready to create symlinks

            TARGET=/storage/symlinks/blackhole/$2
            CACHE=/storage/symlinks/blackhole/.symlink_cache

            echo "Symlinking new items in $ITEMPATH to $TARGET... "
            mkdir -p $TARGET
            mkdir -p $CACHE

            ls "${ITEMPATH}/" | while read -r ITEM
            do
                # symlink to target only if cache doesn't already exist
                # so that if a user moves a file out of the TARGET folder while importing, we don't recreate it
                ln -s "${ITEMPATH}/${ITEM}" "$CACHE/" 2> /dev/null
                if [[ $? -eq 0 ]]; then
                    cp -rs "${ITEMPATH}/${ITEM}" "$TARGET/" 2> /dev/null
                echo "[created symlink] $TARGET/${ITEM}"
                else
                echo "[already exists, skipped] $CACHE/${DIR}${ITEM}"
                fi
            done

            echo "Done! ðŸŽ‰"

            ;;

        "symlink")

            if [[ "$#" -lt 2 ]]; then
                echo "ERROR: path missing - example : 'elfbot symlink /storage/realdebrid-zurg/movies'"
                exit 1
            elif [[ "$2" == "report-broken" ]]; then
                echo "Generating symlink report, see /symlinks/report.txt for details..."
                echo -e "Listing broken symlinks as identified at $(date)..\n\n" > /storage/symlinks/report.txt
                find /storage/elfstorage -xtype l | grep -v .symlinked_cache >> /storage/symlinks/report.txt
                find /storage/symlinks   -xtype l | grep -v .symlinked_cache >> /storage/symlinks/report.txt
                exit 0
            elif [[ "$2" == "delete-broken" ]]; then
                echo "Deleting all broken symlinks..."
                find /storage/symlinks -xtype l -exec rm {} \;
                find /storage/elfstorage -xtype l -exec rm {} \;
                echo ".. Done!"
                exit 0
            elif [[ "$2" == "here" ]]; then
                ITEMPATH="$(pwd)"
            elif [[ ! -d "$2" ]]; then
                echo "ERROR: $2 does not exist"
                exit 1
            else
                ITEMPATH=$2
            fi

            # Never symlink ourselves!
            if [[ $ITEMPATH == *"/storage/symlinks"* ]]; then
                echo "ERROR: Can't symlink a source in /storage/symlinks (#deathbysymlink)"
                exit 1
            fi

            # Get ready to create symlinks
            mkdir -p /storage/symlinks/.symlink_cache

            TARGET=/storage/symlinks/import
            CACHE=/storage/symlinks/.symlink_cache

            # Get the last bit of the source path
            DIR=$(awk -F'/' '{ a = length($NF) ? $NF : $(NF-1); print a }' <<< $ITEMPATH)
            echo "Symlinking new items in $ITEMPATH to $TARGET/${DIR}... "
            mkdir -p "$TARGET/${DIR}"
            mkdir -p "$CACHE/${DIR}"

            ls "${ITEMPATH}/" | while read -r ITEM
            do
                # symlink to target only if cache doesn't already exist
                # so that if a user moves a file out of the TARGET folder while importing, we don't recreate it
                ln -s "${ITEMPATH}/${ITEM}" "$CACHE/${DIR}/" 2> /dev/null
                if [[ $? -eq 0 ]]; then
                    cp -rs "${ITEMPATH}/${ITEM}" "$TARGET/${DIR}/" 2> /dev/null
                fi
            done

            echo "Done! ðŸŽ‰"

            ;;
    esac